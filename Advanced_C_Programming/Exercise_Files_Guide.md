# 📁 Advanced C Programming — Exercise Files 快速導覽

本文件逐一帶過課程 **"Advanced C Programming"** 的每一個 Exercise File (.c)，擷取每題的核心重點與學習目標。由於原始 Exercise Files 受版權保護不上傳至 GitHub，本文件以**重點摘要 + 關鍵程式碼片段**方式呈現，讓你能快速 Scan 每一題該學的內容。

> 📌 **命名規則**：`章節-影片_主題編號.c`（例如 `01-01` = Chapter 1, Video 1）

---

## Chapter 1: Weird-Symbol Roundup（特殊符號總覽）

### `01-01_assignments.c` — 複合賦值運算子

| 學習重點 | 說明 |
|---------|------|
| **主題** | 展示所有基本算術運算：`+`, `-`, `/`, `*`, `%` |
| **核心觀念** | 變數 `v` 從 0 開始，依序經過加減乘除取餘數，產生連鎖運算結果 |
| **重要細節** | `printf` 中要印出 `%` 符號，必須寫成 `%%` |

**關鍵流程**：`v=0 → +20=20 → -2=18 → /3=6 → *4=24 → %7=3`

> 💡 **練習提示**：試著把 `v = v + 20` 改成 `v += 20`，驗證複合運算子的等價性。

---

### `01-04_ternary1.c` — 三元運算子基礎（Max Problem）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `if-else` 解決「兩數取大」問題 |
| **核心觀念** | 這是三元運算子的**對比基線**，展示傳統寫法 |

**關鍵邏輯**：

```c
if (a > b)
    larger = a;
else
    larger = b;
```

> 💡 **練習提示**：將此段改為 `larger = (a > b) ? a : b;`，體會三元運算子的簡潔。

---

### `01-04_ternary2.c` — 三元運算子嵌入函數

| 學習重點 | 說明 |
|---------|------|
| **主題** | 三元運算子作為**表達式**嵌入 `printf` |
| **核心觀念** | 三元運算子有回傳值，可直接放在函式參數中 |
| **注意** | 原始檔案中 `printf` 的三元表達式**故意留空**，需自行填入 |

**該填入的程式碼**：

```c
printf("In this case, variable %c is greater.\n",
        (a > b) ? 'A' : 'B');  // ← 補上這段
```

> 💡 **重點**：三元運算子回傳的是值（這裡是 `char`），不是 statement。

---

### `01-04_ternary3.c` — 巢狀三元運算子

| 學習重點 | 說明 |
|---------|------|
| **主題** | 三元運算子的巢狀 (Nested) 應用 |
| **核心觀念** | 三層判斷：`age < 19` → "kid"，`age < 65` → "adult"，否則 "geezer" |
| **警告** | 巢狀超過 2 層就會嚴重降低可讀性，務必加括號 |

**關鍵邏輯**：

```c
classification = ((age < 19) ? "kid" :
                  (age < 65 ? "adult" : "geezer"));
```

> ⚠️ **最佳實踐**：超過兩層判斷時，改用 `if-else if-else` 更清晰。

---

## Chapter 2: Main Function Arguments（主函數參數）

### `02-01_arguments1.c` — 命令列參數入門

| 學習重點 | 說明 |
|---------|------|
| **主題** | `main(int argc, char *argv[])` 的基本用法 |
| **核心觀念** | `argc` 計算命令列傳入的項目數量（含程式名稱本身） |
| **重要細節** | 即使不傳任何參數，`argc` 也至少為 1（程式名稱） |

**關鍵程式碼**：

```c
int main(int argc, char *argv[])
{
    printf("There were %d command line arguments\n", argc);
    return(0);
}
```

> 💡 **練習提示**：擴充此程式，用 `for` 迴圈遍歷 `argv[]` 印出所有參數。試試加上雙引號的參數（如 `"hello world"`）觀察 `argc` 的變化。

---

## Chapter 3: Beyond Basic Variables（超越基礎變數）

### `03-01_extern1.c` — 區域變數的隔離性

| 學習重點 | 說明 |
|---------|------|
| **主題** | 展示區域變數的作用域 (Scope) |
| **核心觀念** | `main()` 和 `f()` 各自有自己的 `int x`，互不影響 |

**關鍵行為**：

```
main() 中 x = 0
f()    中 x = -1  ← 修改的是 f() 自己的 x
main() 中 x = 0   ← 不受影響
```

> 💡 **對比**：跟 `03-01_extern2.c`（全域變數版）比較，觀察行為差異。

---

### `03-01_extern2.c` — 全域變數的共享效果

| 學習重點 | 說明 |
|---------|------|
| **主題** | 將 `int x` 定義在所有函數之外（全域） |
| **核心觀念** | `main()` 和 `f()` 共享同一個 `x`，`f()` 的修改會影響 `main()` |

**關鍵行為**：

```
main() 中 x = 0
f()    中 x = -1  ← 修改全域 x
main() 中 x = -1  ← 被影響了！
```

> ⚠️ **教訓**：這就是為什麼要避免全域變數——難以追蹤是誰修改了它。

---

### `03-01_extern3_main.c` + `03-01_extern3_manipulate.c` — 跨檔案 `extern`

| 學習重點 | 說明 |
|---------|------|
| **主題** | 兩個 .c 檔案共享全域陣列 |
| **核心觀念** | `main.c` 中**定義** `int data[5]`；`manipulate.c` 中用 `extern int data[]` **宣告**引用 |

**關鍵機制**：

```c
// main.c — 定義 (配置記憶體)
int data[5] = { 2, 3, 5, 7, 9 };

// manipulate.c — 宣告 (不配置記憶體，告知編譯器去別處找)
extern int data[];
```

**程式流程**：`displayData()` → `manipulateData()` (每個元素 ×2) → `displayData()`

> 💡 **重點**：`extern` 不配置記憶體，只是「承諾」連結器會找到它。編譯時兩個 .c 檔需一起編譯：`gcc main.c manipulate.c -o program`

---

### `03-02_cast1.c` — 整數除法陷阱

| 學習重點 | 說明 |
|---------|------|
| **主題** | `int / int` 的截斷問題 |
| **核心觀念** | `10 / 3` = 3（不是 3.33），即使存入 `float` 也是 `3.00` |

**關鍵修正**：

```c
c = a / b;          // ❌ 結果 3.00（已被截斷）
c = (float)a / b;   // ✅ 結果 3.33（正確）
```

> 🔑 **記住**：只要分子或分母**其中一個**是浮點數，就會觸發浮點除法。

---

### `03-02_cast2.c` — 函數的隱式轉型

| 學習重點 | 說明 |
|---------|------|
| **主題** | `sqrt()` 函數的自動轉型 |
| **核心觀念** | `sqrt()` 預期 `double` 參數，C 編譯器會自動將 `int` 隱式轉換 |

> 💡 **不需要**寫 `sqrt((double)a)`，但寫了也不會錯。

---

### `03-02_cast3.c` — 隨機數種子轉型

| 學習重點 | 說明 |
|---------|------|
| **主題** | `srand()` 搭配 `time()` 的慣用寫法 |
| **核心觀念** | `time(NULL)` 回傳 `time_t`，需轉型為 `unsigned` 給 `srand()` |

**固定樣板**：

```c
srand((unsigned)time(NULL));  // 標準寫法，面試可能會問
```

---

### `03-02_cast4.c` — `malloc` 回傳值轉型

| 學習重點 | 說明 |
|---------|------|
| **主題** | 動態記憶體配置的標準寫法 |
| **核心觀念** | `malloc()` 回傳 `void *`，必須轉型為目標型別的指標 |

**固定樣板**：

```c
int *m;
m = (int *)malloc(16 * sizeof(int));  // 配置 16 個 int 的空間
if (m == NULL) { /* 處理錯誤 */ }
```

> 🔑 **面試必考**：`malloc` + `NULL` 檢查 + `free()` 三件套。

---

### `03-05_static1.c` — 靜態變數 vs 區域變數

| 學習重點 | 說明 |
|---------|------|
| **主題** | 展示區域變數在每次函式呼叫時被重置 |
| **核心觀念** | `int x = 0` 每次進入 `f()` 都重新初始化，`x++` 的效果不會保留 |

**輸出**：

```
Value of x is 0    ← 第一次呼叫
Value of x is 1
Value of x is 0    ← 第二次呼叫，又從 0 開始！
Value of x is 1
```

> 💡 **練習提示**：加上 `static` → `static int x = 0;`，觀察第二次呼叫時 x 從 2 開始。

---

### `03-05_static2.c` — 回傳區域陣列的危險

| 學習重點 | 說明 |
|---------|------|
| **主題** | 回傳區域陣列指標的 **Dangling Pointer** 問題 |
| **核心觀念** | 函數內的 `char string[32]` 是區域變數，函數返回後記憶體被回收 |
| **Bug 表現** | 回傳的指標指向已釋放的記憶體，結果是 garbage 或 crash |

**修正方法**：

```c
// ❌ 危險
char string[32];
return string;  // 編譯器警告：回傳區域變數位址

// ✅ 安全
static char string[32];
return string;  // static 讓記憶體在程式結束前不會被回收
```

> ⚠️ **這是 C 語言最常見的 Bug 之一**，面試高頻考題。

---

## Chapter 4: Arrays and Structures（陣列與結構）

### `04-01_arraysort1.c` — Selection Sort 實作

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用雙層迴圈實作 Selection Sort |
| **核心觀念** | 外層迴圈固定位置，內層迴圈找最小值並交換 |
| **隨機數** | 使用 `rand() % 100 + 1` 產生 1~100 的隨機整數 |

**排序核心邏輯**：

```c
for (outer = 0; outer < SIZE; outer++)
    for (inner = outer + 1; inner < SIZE; inner++)
        if (numbers[outer] > numbers[inner]) {
            // 三行交換 (temp swap)
            temp = numbers[inner];
            numbers[inner] = numbers[outer];
            numbers[outer] = temp;
        }
```

> 💡 **記住交換三步驟**：備份 → 覆蓋 → 還原（面試白板題基本功）。

---

### `04-01_arraysort2.c` — 排序過程視覺化

| 學習重點 | 說明 |
|---------|------|
| **主題** | 在每次交換後立即顯示陣列狀態 |
| **核心觀念** | 將 `displayArray()` 放在 swap 區塊內，觀察排序的逐步演進 |
| **額外重點** | 函數原型 `void displayArray(int *a)` — 傳遞陣列即傳遞指標 |

> 💡 **練習提示**：觀察輸出，理解 Selection Sort 為什麼比 Bubble Sort 交換次數更少。

---

### `04-01_arraysort3.c` — `qsort()` 標準函式庫排序

| 學習重點 | 說明 |
|---------|------|
| **主題** | 使用 `stdlib.h` 的 `qsort()` 取代手寫排序 |
| **核心觀念** | 需要自訂 `compare` 函數，搭配 `void *` 轉型 |

**必背樣板**：

```c
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);  // 升序排列
}

qsort(numbers, SIZE, sizeof(int), compare);
```

> 🔑 **面試重點**：理解 `compare` 函數的回傳值意義（負=a在前、正=b在前、零=不動）。
> 
> 💡 **降序排列**：只需改為 `*(int *)b - *(int *)a`。

---

### `04-04_arrayfunct1.c` — 陣列操作模組化

| 學習重點 | 說明 |
|---------|------|
| **主題** | 將 populate、display、sort 拆成獨立函數 |
| **核心觀念** | 傳遞陣列 = 傳遞指標，函數內修改直接影響原始陣列 |
| **注意** | 函數原型可寫 `int a[]` 或 `int *a`，兩者等價 |

**呼叫方式**：

```c
populate(numbers);   // ✅ 只傳陣列名稱
sortArray(numbers);  // ✅ 不加 [], 不加 &
```

> 💡 **重點**：陣列名稱本身就是基底位址，不需要也不能加 `[]`。

---

### `04-04_arrayfunct2.c` — 函數回傳陣列（`static` 版）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 函數內部產生陣列並回傳指標 |
| **核心觀念** | 陣列必須宣告為 `static`，否則函數返回後記憶體無效 |

**關鍵**：

```c
int *generate(void) {
    static int array[10];  // ← static 是必要的
    // ... 填充陣列 ...
    return(array);
}
```

---

### `04-04_arrayfunct3.c` — 更好的做法：傳入陣列讓函數填充

| 學習重點 | 說明 |
|---------|------|
| **主題** | 在 `main` 宣告陣列，傳給函數去填充 |
| **核心觀念** | 避免使用 `static`，由呼叫者管理記憶體 |
| **優勢** | 記憶體管理更清晰，呼叫者控制陣列生命週期 |

**設計模式對比**：

```c
// 方法 A (arrayfunct2)：函數建立並回傳 → 需要 static
int *a = generate();

// 方法 B (arrayfunct3)：呼叫者提供空間 → 更推薦 ✅
int array[10];
generate(array);
```

---

### `04-07_structfunct1.c` — 結構與函數的常見錯誤

| 學習重點 | 說明 |
|---------|------|
| **主題** | 結構定義在 `main()` 內部導致的編譯錯誤 |
| **核心觀念** | 函數原型 `void showStruct(struct person p)` 看不懂定義在 `main` 內的 `struct person` |

> ⚠️ **這段程式碼故意是有 Bug 的！** 編譯會失敗。修正方法：將 `struct person` 的定義移到全域。

---

### `04-07_structfunct2.c` — 正確的結構傳遞（傳值）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 結構定義移至全域後，可正確傳遞給函數 |
| **核心觀念** | `fetchStruct()` 回傳整個結構，`showStruct()` 接收整個結構 |
| **細節** | `fetchStruct` 內用 `static struct person` 確保回傳安全 |

**呼叫鏈**：

```c
showStruct(fetchStruct());  // 函數回傳值直接作為另一個函數的參數
```

---

### `04-07_structfunct3.c` — 結構指標傳遞（最佳實踐）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `malloc` 動態配置結構，全程使用指標操作 |
| **核心觀念** | 傳指標避免結構複製的 overhead，使用 `->` 箭頭運算子 |

**三階段設計**：

```c
struct person *author;
author = allocateStruct();     // 1. malloc + 錯誤處理
fetchStruct(author);           // 2. 用 -> 填入資料
showStruct(author);            // 3. 用 -> 讀取顯示
```

**語法差異對比**：

| 傳值 | 傳指標 |
|------|--------|
| `p.name` | `p->name` |
| `p.age` | `p->age` |

> 🔑 **面試常考**：`.`（點）vs `->` （箭頭）的使用時機。

---

### `04-10_structarray1.c` — 結構陣列（逐一賦值）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 建立 `struct weather week[7]` 並逐一用 `strcpy` 和 `=` 賦值 |
| **核心觀念** | 最基本但最冗長的初始化方式 |

> 💡 **對比**：看 `structarray3.c` 學習更簡潔的初始化寫法。

---

### `04-10_structarray2.c` — 單一結構的預先賦值

| 學習重點 | 說明 |
|---------|------|
| **主題** | 結構變數在宣告時直接初始化 |
| **核心觀念** | `struct weather today = { "Sunday", 72.5 };` — 大括號初始化語法 |

> 💡 **重點**：成員的順序必須與結構定義的順序一致。

---

### `04-10_structarray3.c` — 結構陣列的預先賦值

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用巢狀大括號一次初始化整個結構陣列 |
| **核心觀念** | 比 `structarray1.c` 簡潔許多，推薦使用 |

**簡潔寫法**：

```c
struct weather week[7] = {
    { "Sunday", 72.5 },
    { "Monday", 68.4 },
    // ...
};
```

---

### `04-10_structarray4.c` — 結構的直接賦值（深拷貝）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 結構可以直接用 `=` 賦值，所有成員一次複製 |
| **核心觀念** | `week[1] = week[5];` 會把 Friday 的所有資料完整複製到 Monday |

**執行前後對比**：

```
Monday 68.4 → Friday 72.8  (name 和 temp 全部被覆蓋)
```

> 🔑 **重要特性**：C 語言的結構賦值是**深拷貝**（包含內部的字串陣列），這在排序結構陣列時非常好用。

---

## Chapter 5: Pointer Tips（指標技巧）

### `05-01_ampersand1.c` — `&` 取址運算子基礎

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `%p` 印出不同型別變數的記憶體位址 |
| **核心觀念** | 每個變數都有唯一的記憶體位址，與是否初始化無關 |

**關鍵觀察**：不同型別的變數佔用不同大小的記憶體，位址間隔也不同。

---

### `05-01_ampersand2.c` — 指標存放位址

| 學習重點 | 說明 |
|---------|------|
| **主題** | 指標變數儲存另一個變數的位址 |
| **核心觀念** | `ptra = &a;` 後，`ptra` 和 `&a` 印出的位址完全相同 |

**驗證**：

```c
int a, *ptra;
ptra = &a;
// &a == ptra (兩者印出相同位址)
```

---

### `05-01_ampersand3.c` — 陣列與 `&` 的特殊關係

| 學習重點 | 說明 |
|---------|------|
| **主題** | `a`、`&a`、`ptra` 三者印出的位址完全相同 |
| **核心觀念** | 陣列名稱本身就是指向第一個元素的指標 |

**三個等價表達式**：

```c
int a[10], *ptra;
ptra = a;
// a == &a == ptra (全都是基底位址)
```

> 🔑 **面試重點**：陣列名稱 ≈ 常數指標（不能被重新賦值），但值等同於 `&a[0]`。

---

### `05-02_pointer1.c` — 指標遍歷字串

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `*string` 和 `string++` 遍歷字串直到 `\0` |
| **核心觀念** | `*string` 取出當前字元，`string++` 移動到下一個位元組 |

**標準寫法**：

```c
while (*string != '\0') {
    putchar(*string);
    string++;
}
```

> 💡 `*string != '\0'` 可簡寫為 `*string`（因為 `\0` 就是 0，即 false）。

---

### `05-02_pointer2.c` — `++*s` 的運算子綁定

| 學習重點 | 說明 |
|---------|------|
| **主題** | Prefix increment 作用在**解參考後的值**上 |
| **核心觀念** | `++*s` = 先取出 `*s` 的字元值，再將該字元值 +1（ASCII 值 +1） |

**效果**：`'G'` → `'H'`，`'r'` → `'s'`…每個字元的 ASCII 值加 1。

> ⚠️ **易混淆**：`++*s` 修改的是**字元值**，不是指標位置。指標的移動由獨立的 `s++` 負責。

---

### `05-05_pointerarray1.c` — 陣列索引存取（基線）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 最基本的陣列存取方式：`f[x]` |
| **核心觀念** | 作為後續指標表示法的**對比基線** |

> 💡 後續三個檔案會展示用指標達到完全相同的效果。

---

### `05-05_pointerarray2.c` — 指標遞增遍歷陣列

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `*pf` 取值，`pf++` 移動指標 |
| **核心觀念** | 等同於 `f[x]`，但直接操作記憶體位址 |

```c
pf = f;           // 指向第一個元素
printf("%d", *pf); // 取值
pf++;              // 移到下一個元素
```

> ⚠️ **問題**：`pf++` 會改變指標位置，之後你就**無法**再回到基底位址（除非另外保存）。

---

### `05-05_pointerarray3.c` — 觀察指標算術的位址變化

| 學習重點 | 說明 |
|---------|------|
| **主題** | 同時印出 `%p` (位址) 和 `%d` (值) |
| **核心觀念** | `pf++` 每次增加的不是 1 byte，而是 `sizeof(int)` bytes（通常 4） |

**範例輸出**：

```
0x7ff...00  13    ← 基底位址
0x7ff...04  21    ← +4 bytes
0x7ff...08  34    ← +4 bytes
```

> 🔑 **面試常考**：指標算術自動乘以型別大小，這叫做 **Pointer Arithmetic**。

---

### `05-05_pointerarray4.c` — 指標加位移（最佳實踐）

| 學習重點 | 說明 |
|---------|------|
| **主題** | 用 `*(pf + x)` 取代 `pf++`，保持指標不動 |
| **核心觀念** | 基底位址不變，用 offset 存取不同元素 |

**推薦寫法**：

```c
pf = f;
for (x = 0; x < 5; x++)
    printf("%d\n", *(pf + x));  // pf 始終指向基底
```

> 🔑 **注意括號**：`*(pf + x)` ≠ `*pf + x`。前者是「取第 x 個元素的值」，後者是「取第 0 個元素的值再加 x」。

---

### `05-08_order1.c` — 運算子優先權基礎

| 學習重點 | 說明 |
|---------|------|
| **主題** | 數學運算的優先權：乘除先於加減 |
| **核心觀念** | `5 + 20 * 2 - 8 / 2 = 5 + 40 - 4 = 41` |

> 💡 如果你以為答案是 46 或其他數字，表示你搞混了優先權。

---

### `05-08_order2.c` — Postfix vs Prefix Increment

| 學習重點 | 說明 |
|---------|------|
| **主題** | `a++` (Postfix) 與 `++b` (Prefix) 的根本差異 |
| **核心觀念** | Postfix 先**使用**再加，Prefix 先**加**再使用 |

**關鍵輸出**：

```
a   = 10   b   = 10
a++ = 10   ++b = 11   ← a 使用舊值 10，b 使用新值 11
a   = 11   b   = 11   ← 之後 a 也變成 11
```

> 🔑 **面試必考**：這題幾乎在所有 C 語言面試中都會出現。

---

### `05-08_order3.c` — 終極謎題：`++*s++`

| 學習重點 | 說明 |
|---------|------|
| **主題** | 三個運算子同時作用：`++`(prefix) + `*`(dereference) + `++`(postfix) |
| **核心觀念** | 依照優先權與結合性拆解這個「隱晦的優雅」|

**拆解步驟**：

```
putchar( ++*s++ );

1. s++     → 回傳 s 的「舊位址」，之後將 s 移到下一格
2. *       → 取出「舊位址」的字元值
3. ++      → 字元值 +1 (ASCII +1)
4. putchar → 印出修改後的字元
```

**效果**：將 `"Greetings..."` 每個字元 ASCII +1 後印出，同時逐字移動指標。

> ⚠️ **講師建議**：工作中不要寫這種程式碼，但**必須看得懂**。面試可能會問。

---

## 📊 全課程 Exercise Files 總覽

| 章節 | 檔案數 | 主題 | 難度 |
|------|--------|------|------|
| CH01 | 4 | 賦值運算子、三元運算子 | ⭐ |
| CH02 | 1 | 命令列參數 | ⭐ |
| CH03 | 10 | extern、typecast、static | ⭐⭐ |
| CH04 | 13 | 排序、陣列函數、結構函數、結構陣列 | ⭐⭐⭐ |
| CH05 | 12 | 取址、解參考、指標算術、優先權 | ⭐⭐⭐⭐ |
| **合計** | **40** | — | — |

---

**[End of Guide]**
*本導覽涵蓋課程全部 40 個 Exercise Files，每一題皆已帶過核心重點。*
